Zombie Rails 2

Level 1

Database variable types in rails
string
text
integer
boolean
decimal
float
binary
date
time
datetime


Migration option 
default: value
limit: 30
null: false
first: true
after: :email
unique: true


Add or remove columns to tables
rails g migration add<columns>to<table> name:value
rails g migration Remove<Anything>From<Table name> name:value

Migration commands
rename_column :table, :old_column, :new_column
rename_table  :old_table, :new_table
drop_table	:table
change_column :table, :column, :type, :option
change_column_default :table, :column, default: true
remove_column :table, :column
add_column :table, :column, :type, :option

rake 
rake db:setup -- create db, load schema, run seed
========================================================

Level 2

1  Write a scope on the Tweet model called recent which returns the 4 most recent tweets. Hint: You'll need an order AND a limit scope.

class Tweet < ActiveRecord::Base
  scope :recent, order("created_at desc").limit(4)
end


2  Write another scope called graveyard which only shows tweets where the show_location column is true and the location is "graveyard"

class Tweet < ActiveRecord::Base
  scope :recent, order('created_at desc').limit(4) 
  scope :graveyard, where(show_location: true, location: 'graveyard')
end


3  In this controller action create an instance variable called @graveyard_tweets which uses both of the two scopes recent and graveyard together.

class TweetsController < ApplicationController
  def index
    @tweets = Tweet.all
    @graveyard_tweets = Tweet.recent.graveyard
  end
end


4  Create a before_save callback that checks to see if a tweet has a location, if it does have a location then set show_location to true.
Tip: You can check to see if location exists with if self.location?

class Tweet < ActiveRecord::Base
  before_save :set_show_location
  
  def set_show_location
    self.show_location = true if self.location? #self.location this self is optional
  end
end


5  Add callbacks so the appropriate log function is called after an update and destroy.

class Tweet < ActiveRecord::Base
  after_update :log_update
  after_destroy :log_destroy

  def log_update
    logger.info "Tweet #{id} updated"
  end

  def log_destroy
    logger.info "Tweet #{id} deleted"
  end
end


6 Instead of storing location inside the Tweet model, let's instead break it out into a separate table (as you see below). In this case we want to define that a Tweet can have one Location, and a Location belongs to a Tweet. Fill out the models below accordingly.

class Tweet < ActiveRecord::Base
  has_one :location
end

class Location < ActiveRecord::Base
  belongs_to :tweet
end


****************Pay attendtion of foreign_key*************
7 OH NO! Our Database Admin turned into a Zombie and decided to rename the belongs_to field in our locations table tweeter_id instead of the intelligent default tweet_id. We're going to slay him and correct this, but in the meantime set the foreign_key on both relationships to tweeter_id. Also set the dependency so when a tweet is destroyed, the location is destroyed as well.

class Tweet < ActiveRecord::Base
  has_one :location, dependent: :destroy, foreign_key: :tweeter_id
end

class Location < ActiveRecord::Base
  belongs_to :tweet, foreign_key: :tweeter_id
end


8  We're going to be iterating through many tweets and printing out their location. Refactor the controller code below to use the includes method.

class TweetsController < ApplicationController 
  def index
    @tweets = Tweet.recent.includes(:location).all
  end
end


9  A Tweet can belong to one or more Categories (e.g. eating flesh, walking dead, searching for brains). Write a migration that creates two tables, categories, and categorizations. Give categories one column named name of type string; and give categorizations two integer columns: tweet_id and category_id.

class AddTweetCategories < ActiveRecord::Migration
  def change
    create_table :categories do |t|
      t.string :name
    end
    
    create_table :categorizations do |t|
      t.integer :tweet_id
      t.integer :category_id
    end
  end 
end


10 Now that we have our new tables, it's time to define the relationships between each of the models. Define the has_many through relationships in the Tweet & Category model and the belongs_to relationships in the Categorization model.

class Tweet < ActiveRecord::Base
  has_many :categorizations
  has_many :categories, through: :categorizations
end

class Categorization < ActiveRecord::Base
  belongs_to :tweet
  belongs_to :category
end

class Category < ActiveRecord::Base
  has_many :categorizations
  has_many :tweets, through: :categorizations
end

=====================================================

Level 3

radio button

<%= f.radio_button :decomp, 'fresh', checked: true %>

select

<%= f.select :decomp, [['fresh', 1], ['rotting', 2], ['stale', 3]]%>

test input helper

<%= f.password_field :password %>

<%= f.number_field :price %>

<%= f.range_field :quantity %>

Nested routes
pic-- Code School - Rails for Zombies Two-nested routes


Challenges

2 Create the form for entering tweet status (text_area) and location (text_field) using the appropriate Rails view helpers. All you need is a form_for block, the input helpers, and a submit button.


<h1>New tweet</h1>

<%= form_for(@tweet) do |f| %>
  <%= f.text_area :status %>
  <%= f.text_field :location %>
  <%= f.submit value='Submit' %>
<% end %>


3 Look at the following database table and create the proper input fields for the columns listed here.

<%= form_for(@weapon) do |f| %>
  <%= f.text_field :name %>
  <%= f.number_field :ammo %>
  <%= f.check_box :is_broken %>
<% end %>


4 Rather than having a weapon that is broken or not, lets instead have a condition field which is either "New", "Rusty", or "Broken". Add a set of radio buttons where the user can select one of these states. Make "New" be checked by default.

<%= form_for(@weapon) do |f| %>
  <%= f.text_field :name %>
  <%= f.number_field :ammo %>
  <%= f.radio_button :condition, 'New', checked: true %>
  <%= f.radio_button :condition, 'Rusty' %>
  <%= f.radio_button :condition, 'Broken' %>
<% end %>


5  Instead of using radio buttons, use a select box for the condition. Refactor the code below:

<%= form_for(@weapon) do |f| %>
  <%= f.select :condition, ['New', 'Rusty', 'Broken'] %>
<% end %>


6 Write the nested route that will allow us to nest tweets and weapons under the zombie resource. The idea here is that a zombie has many tweets and zombie has many weapons.

RailsForZombies::Application.routes.draw do
  resources :zombies do
    resources :tweets
    resources :weapons
  end
end


7  Now that we have the proper route, we need to make sure the weapons controller properly looks up both the zombie and the weapon when we request /zombies/2/weapons/1. Finish this controller:

class WeaponsController < ApplicationController
  def show 
    @zombie = Zombie.find(2)
    @weapon = @zombie.weapons.find(1)
  end
end


8  Now create the proper link_to for when we view a zombie and want to show each of its weapons, and when we want to create a new weapon for this zombie.

<h2><%= @zombie.name %>'s weapons</h2>
<ul>
  <% @weapons.each do |w| %>
    <li><%= link_to w.name, [@zombie, w] %></li>
  <% end %>
</ul>

<%= link_to "New Weapon", new_zombie_weapon_path(@zombie) %>


9 Change the form_for below to use the proper nesting for creating a new weapon for a Zombie.

<%= form_for([@zombie, @weapon]) do |f| %>
  <%= f.text_field :name %>
    
  <%= f.submit %>
<% end %>


10 Modify the following code to make it more pretty, using titleize, to_sentence, pluralize, and number_to_currency (in just that order)

<h2><%= @zombie.name.titleize %></h2>
<p>Weapons: <%= @zombie.weapon_list.to_sentence %></p>
<p><%= pluralize(@zombie.tweets.size, 'Tweet') %></p>
<p>Money in Pocket <%= number_to_currency(@zombie.money) %></p>


11 Refactor the code below to move the form into the _form.html.erb partial.

<h2>New Tweet</h2>

<%= render 'form' %>

<%= link_to 'back', tweets_path %>

=========================================================================

Level 5

1  Enter the command for generating a mailer called WeaponMailer which has the emails low_ammo and broken.

rails g mailer WeaponMailer low_ammo broken


2  Code up the low_ammo mailer with the subject of "#{weapon.name} has low ammo", the email should be sent to the zombie.email. Lastly, set the default from address for all emails in WeaponMailer to admin@rfz.com


class WeaponMailer < ActionMailer::Base
  default from: "admin@rfz.com"
  def low_ammo(weapon, zombie) 
    mail to: zombie.email, subject: "#{weapon.name} has low ammo"
    
  end
end

3  Finish coding the check_ammo method on the Weapon model so when we have exactly three ammo left, it will send out the low_ammo mailer we just created.

class Weapon < ActiveRecord::Base
  belongs_to :zombie 

  before_save :check_ammo

  def check_ammo
    if ammo == 3
      WeaponMailer.low_ammo(self, self.zombie).deliver
    end
  end
end

4 Change the low_ammo method to include a picture of the weapon that's low on ammo as an attachment. You can name the file weapon.jpg and load the file using weapon.picture_file.

class WeaponMailer < ActionMailer::Base
  default from: "admin@rfz.com"

  def low_ammo(weapon, zombie)
    attachments['weapon.jpg'] = weapon.picture_file
    mail to: zombie.email, subject: "#{weapon.name} has low ammo"
  end 
end

5 Convert the following to their appropriate asset tags.


<%= javascript_include_tag "weapon" %>
<%= image_tag "weapon.png" %>
<%= stylesheet_link_tag "weapon" %>

6 Convert the following scss.erb file to properly reference the asset_path for the image listed in it. Also, try refactoring the scss to use nesting.

h2#newUser {
  text-indent: -9999px; 
  a {
      height: 64px;
      width: 50px;
      display: block;
      background: url(<%= asset_path('rails.png') %>) no-repeat;
  }
}

7 Use CoffeeScript so when the New Weapon link is pressed it makes the #newWeapon div visible and then hides the New Weapon link. Don't forget to call preventDefault().

$(document).ready ->
  $('#displayWeaponForm').click (event) ->
    event.preventDefault()
    $(this).hide()
    $('#newWeapon').show()


======================================================================

Level 5

1 Complete the method below so that if the ammo is low it will render the fire_and_reload view, otherwise it should render the fire_weapon view.

class WeaponsController < ApplicationController
  def fire_weapon
    @weapon = Weapon.find(params[:id]) 
    @weapon.fire!

    if @weapon.low_ammo?
      render 'fire_and_reload'
    end

  end
end

2 Create two custom member routes on the weapons resource, so you have a put method called toggle_condition and a put method called reload.

RailsForZombies::Application.routes.draw do
  resources :zombies do
    resources :weapons do
      put :toggle_condition, on: :member
      put :reload, on: :member
    end
  end
end


3 Complete the create method below. When @weapon.save is successful it should render the @weapon object in JSON, have status :created, and set the location to the @weapon's show url. When @weapon.save fails it should return the @weapon.errors and have the status :unprocessable_entity.

class WeaponsController < ApplicationController 
  def create
    @weapon = Weapon.new(params[:weapon]) 
    if @weapon.save
      render json: @weapon, status: :created, location: @weapon
      
    else
      render json: @weapon.errors, status: :unprocessable_entity
    end
  end 
end

4  Complete the controller so that it returns in JSON only the amount of ammo which is left in the weapon. If the ammo has less than 30 bullets it should return the status code :ok, and if not it should return the status code :unprocessable_entity.

class WeaponsController < ApplicationController
  def reload
    @weapon = Weapon.find(params[:id]) 

    if @weapon.ammo < 30
      @weapon.reload(params[:ammo_to_reload])
      render json: @weapon.to_json(only: :ammo), status: :ok
    else
      render json: @weapon.to_json(only: :ammo), status: :unprocessable_entity
    end
  end
end


5 Modify the show action so that the JSON it renders includes the zombie record the @weapon belongs to. Also make it exclude the :id, :created_at, and :updated_at fields.

class WeaponsController < ApplicationController
  def show
    @weapon = Weapon.find(params[:id])
    render json: @weapon.to_json(include: :zombie, except: [:id, :created_at, :updated_at])
  end
end

6 Edit the as_json method so the Zombie class only returns the zombie's name and weapons (use include). Only return the weapon's name and ammo.

class Zombie < ActiveRecord::Base
  has_many :weapons

  def as_json(options=nil)
    super(options || 
      {only: :name, include: :weapons, only: [:name, :ammo]})
  end 
end


7 Modify the show.html.erb view below so that both the Toggle link and the Reload form use AJAX. All you need to do is add the option that makes them ajaxified.

<ul>
  <li>
    <em>Name:</em> <%= @weapon.name %>
  </li> 
  <li>
    <em>Condition:</em>
    <span id="condition"><%= @weapon.condition %></span>
    <%= link_to "Toggle", toggle_condition_weapon_path(@weapon), remote: true %>
  </li> 
  <li>
    <em>Ammo:</em>
    <span id="ammo"><%= @weapon.ammo %></span>
  </li>
</ul>

<%= form_for @weapon, url: reload_weapon_path(@weapon), remote: true do |f| %>
  <div class="field">
    Number of bullets to reload:
    <%= number_field_tag :ammo_to_reload, 30 %> <br /> <%= f.submit "Reload" %>
  </div>
<% end %>

8 Modify the toggle_condition action so that it responds to JavaScript, and complete the toggle_condition.js.erb using jQuery to update the condition span with the @weapon's changed condition and make it highlight.

$('span#condition').append("<%= escape_javascript(@weapon.condition) %>").effect('highlight');

9 Now write the controller and JavaScript code needed to properly reload the weapon using the ajaxified form. In the reload.js.erb use jQuery to update the #ammo text to the current @weapon.ammo value and if the ammo value is over or equal to 30, fadeOut the #reload_form div.

$('span#ammo').text("<%= @weapon.ammo %>");
<% if @weapon.ammo >= 30 %>
  $('div#reload_form').fadeOut();
<% end %>

10 Instead of returning jQuery which gets executed on the client-side, lets write the ajax request in CoffeeScript communicating with JSON. It should do the same thing as the last challenge, updating & highlighting the ammo, and fading out the form (hint: fade out the wrapper element) if ammo is equal or above 30. 
Tip for your ajax form: data: {ammo_to_reload: ammo}.

$(document).ready ->
  $('div#reload_form form').submit (event) ->
    event.preventDefault()
    url = $(this).attr('action')
    ammo = $('#ammo_to_reload').val()
    
    $.ajax
      type: 'put'
      url: url
      data: {weapon: {ammo: ammo} }
      dataType: 'json'
      success: (json) -> 
        $('#ammo').text(json.ammo).effect('highlight')
        $('#reload_form').fadeOut() if json.ammo >= 0

============================================================

ScreenCast

Asset Pipline

bundle open jquery-rails
rails s -e production
rake assets:precompile        

================================================

Ruby Bits

Level 2

2 We want to make sure that each game is a valid game object - in this case a simple hash of values. Even still, we wouldn't want to return a hash with a nil name. Raise an InvalidGameError error in the new_game method if name is nil.

class InvalidGameError < StandardError; end
def new_game(name, options={})
  raise InvalidGameError, "You must provide a name" if name.nil?
  {
    name: name,
    year: options[:year],
    system: options[:system]
  }
end
begin
  game = new_game(nil)
rescue InvalidGameError => e
  puts "There was a problem creating your new game: #{e.message}"
end

3 When passing in an array of arguments to a method, sometimes it'll make sense to use Ruby's "splat" operator rather than explicitly requesting an array. Update the describe_favorites method and the call to it to instead use the splat operator.

def describe_favorites(*games)
  for game in games
    puts "Favorite Game: #{game}"
  end  
end
describe_favorites('Mario', 'Contra', 'Metroid')

4 Passing around hashes is getting troublesome, let's use a class to hold our data. We've started the Game class for you, now please implement the initialize method to store name, system and year in instance variables.

class Game
  def initialize(name, options={})
    @name=name
    @year=options[:year]
    @system=options[:system]
  end
end

6 attr_accessor
Whoever created the game object will want to be able to access the name, year and system for the game, but that doesn't mean we need to make getter methods for them. Refactor the code below to make these variables available using the Ruby way with attr_accessor.

class Game
  attr_accessor :name, :year, :system
  def initialize(name, options={})
    @name = name
    @year = options[:year]
    @system = options[:system]
  end
end

7 When a game is initialized, store another variable called created_at which is set to Time.now in the initialize method. Make sure it can be accessed, but that it cannot be set from outside the object.

class Game
  attr_accessor :name, :year, :system
  attr_reader :created_at
  def initialize(name, options={})
    @name = name
    @year = options[:year]
    @system = options[:system]
    @created_at = Time.new
  end
end

level 3

1 

class Library
  attr_accessor :games
  def initialize(games)
    @games = games
  end
end

2

class Library
  attr_accessor :games

  def initialize(games)
    self.games = games
  end

  def has_game?(game)
    for game in games
      return true if game == @game
    end
    false
  end
end

3 We can initialize our Library with an array of games, but the only way to add games from outside the class is to use the games accessor method and alter the array. This is breaking encapsulation, so let's create a new method in Library called add_game which takes in a game and adds it to the games array.

class Library
  attr_accessor :games

  def add_game(game)
    self.games << game
  end
  
  def initialize(games)
    self.games = games
  end

  def has_game?(search_game)
    for game in games
      return true if game == search_game
    end
    false
  end
end

4 Things are looking good! We're able to use our Library class to store our games now. Whenever we call add_game, let's call a new private method called log which will call puts with some information about the game that was added. Your log method should take in a string to be displayed.

class Library
  attr_accessor :games

  def initialize(games)
    self.games = games
  end

  def has_game?(search_game)
    for game in games
      return true if game == search_game
    end
    false
  end

  def add_game(game)
    self.games << game
    log("The game name is #{game.name}, it was built in #{game.year}, for #{game.system}")
  end
  
  private 
  
  def log(message)
    puts message
  end
end

5

class ArcadeGame < Game
end
class ConsoleGame < Game
end

6 Inheritance II
For our ArcadeGame class, we'll also want to track the weight of these giant cabinets taking up all of our available space. Luckily we thought ahead: we already take in an options parameter that we can stick weight into! Override the initialize method for ArcadeGame to take in the same parameters as its parent class, call super, and then set weight.

class ArcadeGame < Game
  attr_accessor :weight
  def initialize(name, options={})
    super
    self.weight = options[:weight]
  end
end
class ConsoleGame < Game
end

7 Inheritance III
Whenever we output a game right now it'll show up using the to_s method from Object, the parent object of Game. A basic to_s implementation is completed below on Game. Override this for ConsoleGame to also show the system the game is on.

class ConsoleGame < Game
  def to_s
    super + self.system
  end
end

8 Refactoring
Our to_s method will come in very handy. Whenever we need to output a game, rather than calling a method on the game, we can just output the game object and Ruby will call to_s on it automatically. Refactor both classes below. Change the description method of Game to use the to_s method implicitly. Then remove any duplicated code in ConsoleGame. Note: you'll need to use self inside a class to reference the entire object.

Original
class Game
  attr_accessor :name, :year, :system
  attr_reader :created_at
  def initialize(name, options={})
    self.name = name
    self.year = options[:year]
    self.system = options[:system]
    @created_at = Time.now
  end

  def to_s
    self.name
  end

  def description
    "#{self.name} was released in #{self.year}."
  end
end

class ConsoleGame < Game
  def to_s
    "#{self.name} - #{self.system}"
  end

  def description
    "#{self.name} - #{self.system} was released in #{self.year}."
  end
end

Changed
class Game
  attr_accessor :name, :year, :system
  attr_reader :created_at
  def initialize(name, options={})
    self.name = name
    self.year = options[:year]
    self.system = options[:system]
    @created_at = Time.now
  end

  def to_s
    self.name
  end

  def description
    "#{self} was released in #{self.year}."
  end
end

class ConsoleGame < Game
  def to_s
    "#{super} - #{self.system}"
  end
end
