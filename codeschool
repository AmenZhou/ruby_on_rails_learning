Zombie Rails 2

Level 1

Database variable types in rails
string
text
integer
boolean
decimal
float
binary
date
time
datetime


Migration option 
default: value
limit: 30
null: false
first: true
after: :email
unique: true


Add or remove columns to tables
rails g migration add<columns>to<table> name:value
rails g migration Remove<Anything>From<Table name> name:value

Migration commands
rename_column :table, :old_column, :new_column
rename_table  :old_table, :new_table
drop_table	:table
change_column :table, :column, :type, :option
change_column_default :table, :column, default: true
remove_column :table, :column
add_column :table, :column, :type, :option

rake 
rake db:setup -- create db, load schema, run seed
========================================================

Level 2

1  Write a scope on the Tweet model called recent which returns the 4 most recent tweets. Hint: You'll need an order AND a limit scope.

class Tweet < ActiveRecord::Base
  scope :recent, order("created_at desc").limit(4)
end


2  Write another scope called graveyard which only shows tweets where the show_location column is true and the location is "graveyard"

class Tweet < ActiveRecord::Base
  scope :recent, order('created_at desc').limit(4) 
  scope :graveyard, where(show_location: true, location: 'graveyard')
end


3  In this controller action create an instance variable called @graveyard_tweets which uses both of the two scopes recent and graveyard together.

class TweetsController < ApplicationController
  def index
    @tweets = Tweet.all
    @graveyard_tweets = Tweet.recent.graveyard
  end
end


4  Create a before_save callback that checks to see if a tweet has a location, if it does have a location then set show_location to true.
Tip: You can check to see if location exists with if self.location?

class Tweet < ActiveRecord::Base
  before_save :set_show_location
  
  def set_show_location
    self.show_location = true if self.location? #self.location this self is optional
  end
end


5  Add callbacks so the appropriate log function is called after an update and destroy.

class Tweet < ActiveRecord::Base
  after_update :log_update
  after_destroy :log_destroy

  def log_update
    logger.info "Tweet #{id} updated"
  end

  def log_destroy
    logger.info "Tweet #{id} deleted"
  end
end


6 Instead of storing location inside the Tweet model, let's instead break it out into a separate table (as you see below). In this case we want to define that a Tweet can have one Location, and a Location belongs to a Tweet. Fill out the models below accordingly.

class Tweet < ActiveRecord::Base
  has_one :location
end

class Location < ActiveRecord::Base
  belongs_to :tweet
end


****************Pay attendtion of foreign_key*************
7 OH NO! Our Database Admin turned into a Zombie and decided to rename the belongs_to field in our locations table tweeter_id instead of the intelligent default tweet_id. We're going to slay him and correct this, but in the meantime set the foreign_key on both relationships to tweeter_id. Also set the dependency so when a tweet is destroyed, the location is destroyed as well.

class Tweet < ActiveRecord::Base
  has_one :location, dependent: :destroy, foreign_key: :tweeter_id
end

class Location < ActiveRecord::Base
  belongs_to :tweet, foreign_key: :tweeter_id
end


8  We're going to be iterating through many tweets and printing out their location. Refactor the controller code below to use the includes method.

class TweetsController < ApplicationController 
  def index
    @tweets = Tweet.recent.includes(:location).all
  end
end


9  A Tweet can belong to one or more Categories (e.g. eating flesh, walking dead, searching for brains). Write a migration that creates two tables, categories, and categorizations. Give categories one column named name of type string; and give categorizations two integer columns: tweet_id and category_id.

class AddTweetCategories < ActiveRecord::Migration
  def change
    create_table :categories do |t|
      t.string :name
    end
    
    create_table :categorizations do |t|
      t.integer :tweet_id
      t.integer :category_id
    end
  end 
end


10 Now that we have our new tables, it's time to define the relationships between each of the models. Define the has_many through relationships in the Tweet & Category model and the belongs_to relationships in the Categorization model.

class Tweet < ActiveRecord::Base
  has_many :categorizations
  has_many :categories, through: :categorizations
end

class Categorization < ActiveRecord::Base
  belongs_to :tweet
  belongs_to :category
end

class Category < ActiveRecord::Base
  has_many :categorizations
  has_many :tweets, through: :categorizations
end

=====================================================

Level 3

radio button

<%= f.radio_button :decomp, 'fresh', checked: true %>

select

<%= f.select :decomp, [['fresh', 1], ['rotting', 2], ['stale', 3]]%>

test input helper

<%= f.password_field :password %>

<%= f.number_field :price %>

<%= f.range_field :quantity %>

Nested routes
pic-- Code School - Rails for Zombies Two-nested routes


Challenges

2 Create the form for entering tweet status (text_area) and location (text_field) using the appropriate Rails view helpers. All you need is a form_for block, the input helpers, and a submit button.


<h1>New tweet</h1>

<%= form_for(@tweet) do |f| %>
  <%= f.text_area :status %>
  <%= f.text_field :location %>
  <%= f.submit value='Submit' %>
<% end %>


3 Look at the following database table and create the proper input fields for the columns listed here.

<%= form_for(@weapon) do |f| %>
  <%= f.text_field :name %>
  <%= f.number_field :ammo %>
  <%= f.check_box :is_broken %>
<% end %>


4 Rather than having a weapon that is broken or not, lets instead have a condition field which is either "New", "Rusty", or "Broken". Add a set of radio buttons where the user can select one of these states. Make "New" be checked by default.

<%= form_for(@weapon) do |f| %>
  <%= f.text_field :name %>
  <%= f.number_field :ammo %>
  <%= f.radio_button :condition, 'New', checked: true %>
  <%= f.radio_button :condition, 'Rusty' %>
  <%= f.radio_button :condition, 'Broken' %>
<% end %>


5  Instead of using radio buttons, use a select box for the condition. Refactor the code below:

<%= form_for(@weapon) do |f| %>
  <%= f.select :condition, ['New', 'Rusty', 'Broken'] %>
<% end %>


6 Write the nested route that will allow us to nest tweets and weapons under the zombie resource. The idea here is that a zombie has many tweets and zombie has many weapons.

RailsForZombies::Application.routes.draw do
  resources :zombies do
    resources :tweets
    resources :weapons
  end
end


7  Now that we have the proper route, we need to make sure the weapons controller properly looks up both the zombie and the weapon when we request /zombies/2/weapons/1. Finish this controller:

class WeaponsController < ApplicationController
  def show 
    @zombie = Zombie.find(2)
    @weapon = @zombie.weapons.find(1)
  end
end


8  Now create the proper link_to for when we view a zombie and want to show each of its weapons, and when we want to create a new weapon for this zombie.

<h2><%= @zombie.name %>'s weapons</h2>
<ul>
  <% @weapons.each do |w| %>
    <li><%= link_to w.name, [@zombie, w] %></li>
  <% end %>
</ul>

<%= link_to "New Weapon", new_zombie_weapon_path(@zombie) %>


9 Change the form_for below to use the proper nesting for creating a new weapon for a Zombie.

<%= form_for([@zombie, @weapon]) do |f| %>
  <%= f.text_field :name %>
    
  <%= f.submit %>
<% end %>


10 Modify the following code to make it more pretty, using titleize, to_sentence, pluralize, and number_to_currency (in just that order)

<h2><%= @zombie.name.titleize %></h2>
<p>Weapons: <%= @zombie.weapon_list.to_sentence %></p>
<p><%= pluralize(@zombie.tweets.size, 'Tweet') %></p>
<p>Money in Pocket <%= number_to_currency(@zombie.money) %></p>


11 Refactor the code below to move the form into the _form.html.erb partial.

<h2>New Tweet</h2>

<%= render 'form' %>

<%= link_to 'back', tweets_path %>